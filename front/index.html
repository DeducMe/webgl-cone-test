<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGl Test</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <form class="controls" id="controlsForm">
        <label for="heightInput">Height</label>
        <input name="heightInput" id="heightInput" type="number">

        <label for="radiusInput">Radius</label>
        <input name="radiusInput" id="radiusInput" type="number">
        
        <label for="segmentsInput">Segments number</label>
        <input name="segmentsInput" id="segmentsInput" type="number">

        <button type="submit">POST</button>
    </form>
</body>

<script>
    
</script>

<script type="module">

    import * as THREE from './three/three.module.js';

    import { OrbitControls } from './three/OrbitControls.js';
    import { ConvexGeometry } from './three/ConvexGeometry.js';
    import { BufferGeometryUtils } from './three/BufferGeometryUtils.js';

    let group, camera, mesh, scene, renderer;

    function getConeData(height, radius, segments){
        fetch('/post', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                height: height || 10,
                radius: radius || 2,
                segments: segments || 10,
            })
        })
        .then(response=>response.json())
        .then(data => init(data));
    }

    getConeData(10, 3, 20)

    const controlsForm = document.getElementById('controlsForm')
    controlsForm.addEventListener('submit', (e)=>{
        e.preventDefault()
        getConeData(e.target.heightInput.value, e.target.radiusInput.value, Math.abs(e.target.segmentsInput.value))
        console.log('post')
    })


    scene = new THREE.Scene();

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    // camera

    camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.set( 15, 20, 30 );
    scene.add( camera );

    // controls

    const controls = new OrbitControls( camera, renderer.domElement );
    controls.minDistance = 20;
    controls.maxDistance = 50;
    controls.maxPolarAngle = Math.PI / 2;

    // ambient light

    scene.add( new THREE.AmbientLight( 0x222222 ) );

    // point light

    const light = new THREE.PointLight( parseInt ( '#e0e0e0'.replace("#","0x"), 16 )  );
    camera.add( light );

    // helper

    scene.add( new THREE.AxesHelper( 20 ) );

    // textures

    group = new THREE.Group();
    scene.add( group );

    animate()
    function init(coneData) {
        scene.remove(mesh);
        // points

        let geometry = new THREE.BufferGeometry();
        
        geometry.setAttribute( 'position', new THREE.BufferAttribute( Float32Array.from(Object.values(coneData.positions)), 3 ) );
        geometry.setAttribute( 'normal', new THREE.BufferAttribute( Float32Array.from(Object.values(coneData.normals)), 3 ) );
        geometry.setAttribute( 'color', new THREE.BufferAttribute( Float32Array.from(Object.values(coneData.colors)), 3 ) );

        geometry.computeBoundingSphere();

        let material = new THREE.MeshPhongMaterial( {
            color: 0xaaaaaa, specular: 0xffffff, shininess: 250,
            side: THREE.DoubleSide, vertexColors: true
        } );

        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );

        const pointsMaterial = new THREE.PointsMaterial( {

            color: 0x0080ff,
            size: 1,
            alphaTest: 0.5

        } );

       
        //

        window.addEventListener( 'resize', onWindowResize );

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function animate() {

        requestAnimationFrame( animate );

        group.rotation.y += 0.005;

        render();

    }

    function render() {

        renderer.render( scene, camera );

    }

</script>
</html>